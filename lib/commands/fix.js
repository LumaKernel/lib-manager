"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fix = fix;
exports.applyLibraries = applyLibraries;
exports.applyTemplates = applyTemplates;

require("source-map-support/register");

var _fs = require("fs");

var _path = _interopRequireDefault(require("path"));

var _backup = _interopRequireDefault(require("../makers/backup"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const {
  resolve
} = _path.default;

function fix(config, project) {
  (0, _backup.default)(config);
  applyLibraries(config, project.files, project.libs, true);
  applyTemplates(config, project.templates, true);
}
/**
 * backup before using
 */


function applyLibraries(config, files, libs, apply = false) {
  const src = resolve(process.cwd(), config.WorkingDir, config.SrcDir);
  const changes = [];
  files.forEach(({
    namespace,
    filename,
    data
  }) => {
    let changed = false;
    const refacrtored = data.map(name => {
      if (libs[name].old !== libs[name].refactored) changed = true;
      return libs[name].refactored;
    }).join('\n');
    if (!changed) return;
    const path = resolve(src, ...namespace.split('/'), filename);
    changes.push([...namespace.split('/'), filename].filter(e => e).join('/'));
    if (apply) (0, _fs.writeFileSync)(path, refacrtored);
  });
  return changes;
}
/**
 * backup before using
 */


function applyTemplates(config, templates, apply = false) {
  const src = resolve(process.cwd(), config.WorkingDir, config.SrcDir);
  const changes = [];
  Object.keys(templates).forEach(key => {
    const el = templates[key];
    if (el.code === el.old) return;
    const path = resolve(src, ...el.namespace.split('/'), el.filename);
    changes.push([...el.namespace.split('/'), el.filename].filter(e => e).join('/'));
    if (apply) (0, _fs.writeFileSync)(path, el.code);
  });
  return changes;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9jb21tYW5kcy9maXguanMiXSwibmFtZXMiOlsicmVzb2x2ZSIsInBhdGgiLCJmaXgiLCJjb25maWciLCJwcm9qZWN0IiwiYXBwbHlMaWJyYXJpZXMiLCJmaWxlcyIsImxpYnMiLCJhcHBseVRlbXBsYXRlcyIsInRlbXBsYXRlcyIsImFwcGx5Iiwic3JjIiwicHJvY2VzcyIsImN3ZCIsIldvcmtpbmdEaXIiLCJTcmNEaXIiLCJjaGFuZ2VzIiwiZm9yRWFjaCIsIm5hbWVzcGFjZSIsImZpbGVuYW1lIiwiZGF0YSIsImNoYW5nZWQiLCJyZWZhY3J0b3JlZCIsIm1hcCIsIm5hbWUiLCJvbGQiLCJyZWZhY3RvcmVkIiwiam9pbiIsInNwbGl0IiwicHVzaCIsImZpbHRlciIsImUiLCJPYmplY3QiLCJrZXlzIiwia2V5IiwiZWwiLCJjb2RlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUNBOzs7O0FBQ0EsTUFBTTtBQUFFQSxFQUFBQTtBQUFGLElBQWNDLGFBQXBCOztBQUVPLFNBQVNDLEdBQVQsQ0FBY0MsTUFBZCxFQUFzQkMsT0FBdEIsRUFBK0I7QUFDcEMsdUJBQU9ELE1BQVA7QUFDQUUsRUFBQUEsY0FBYyxDQUFDRixNQUFELEVBQVNDLE9BQU8sQ0FBQ0UsS0FBakIsRUFBd0JGLE9BQU8sQ0FBQ0csSUFBaEMsRUFBc0MsSUFBdEMsQ0FBZDtBQUNBQyxFQUFBQSxjQUFjLENBQUNMLE1BQUQsRUFBU0MsT0FBTyxDQUFDSyxTQUFqQixFQUE0QixJQUE1QixDQUFkO0FBQ0Q7QUFFRDs7Ozs7QUFHTyxTQUFTSixjQUFULENBQXlCRixNQUF6QixFQUFpQ0csS0FBakMsRUFBd0NDLElBQXhDLEVBQThDRyxLQUFLLEdBQUcsS0FBdEQsRUFBNkQ7QUFDbEUsUUFBTUMsR0FBRyxHQUFHWCxPQUFPLENBQUNZLE9BQU8sQ0FBQ0MsR0FBUixFQUFELEVBQWdCVixNQUFNLENBQUNXLFVBQXZCLEVBQW1DWCxNQUFNLENBQUNZLE1BQTFDLENBQW5CO0FBQ0EsUUFBTUMsT0FBTyxHQUFHLEVBQWhCO0FBQ0FWLEVBQUFBLEtBQUssQ0FBQ1csT0FBTixDQUFjLENBQUM7QUFBQ0MsSUFBQUEsU0FBRDtBQUFZQyxJQUFBQSxRQUFaO0FBQXNCQyxJQUFBQTtBQUF0QixHQUFELEtBQWlDO0FBQzdDLFFBQUlDLE9BQU8sR0FBRyxLQUFkO0FBQ0EsVUFBTUMsV0FBVyxHQUFHRixJQUFJLENBQ3JCRyxHQURpQixDQUNiQyxJQUFJLElBQUk7QUFDWCxVQUFJakIsSUFBSSxDQUFDaUIsSUFBRCxDQUFKLENBQVdDLEdBQVgsS0FBbUJsQixJQUFJLENBQUNpQixJQUFELENBQUosQ0FBV0UsVUFBbEMsRUFBOENMLE9BQU8sR0FBRyxJQUFWO0FBQzlDLGFBQU9kLElBQUksQ0FBQ2lCLElBQUQsQ0FBSixDQUFXRSxVQUFsQjtBQUNELEtBSmlCLEVBS2pCQyxJQUxpQixDQUtaLElBTFksQ0FBcEI7QUFNQSxRQUFJLENBQUNOLE9BQUwsRUFBYztBQUNkLFVBQU1wQixJQUFJLEdBQUdELE9BQU8sQ0FBQ1csR0FBRCxFQUFNLEdBQUdPLFNBQVMsQ0FBQ1UsS0FBVixDQUFnQixHQUFoQixDQUFULEVBQStCVCxRQUEvQixDQUFwQjtBQUNBSCxJQUFBQSxPQUFPLENBQUNhLElBQVIsQ0FBYSxDQUFDLEdBQUdYLFNBQVMsQ0FBQ1UsS0FBVixDQUFnQixHQUFoQixDQUFKLEVBQTBCVCxRQUExQixFQUFvQ1csTUFBcEMsQ0FBMkNDLENBQUMsSUFBSUEsQ0FBaEQsRUFBbURKLElBQW5ELENBQXdELEdBQXhELENBQWI7QUFDQSxRQUFJakIsS0FBSixFQUFXLHVCQUFjVCxJQUFkLEVBQW9CcUIsV0FBcEI7QUFDWixHQVpEO0FBYUEsU0FBT04sT0FBUDtBQUNEO0FBRUQ7Ozs7O0FBR08sU0FBU1IsY0FBVCxDQUF5QkwsTUFBekIsRUFBaUNNLFNBQWpDLEVBQTRDQyxLQUFLLEdBQUcsS0FBcEQsRUFBMkQ7QUFDaEUsUUFBTUMsR0FBRyxHQUFHWCxPQUFPLENBQUNZLE9BQU8sQ0FBQ0MsR0FBUixFQUFELEVBQWdCVixNQUFNLENBQUNXLFVBQXZCLEVBQW1DWCxNQUFNLENBQUNZLE1BQTFDLENBQW5CO0FBQ0EsUUFBTUMsT0FBTyxHQUFHLEVBQWhCO0FBQ0FnQixFQUFBQSxNQUFNLENBQUNDLElBQVAsQ0FBWXhCLFNBQVosRUFBdUJRLE9BQXZCLENBQStCaUIsR0FBRyxJQUFJO0FBQ3BDLFVBQU1DLEVBQUUsR0FBRzFCLFNBQVMsQ0FBQ3lCLEdBQUQsQ0FBcEI7QUFDQSxRQUFJQyxFQUFFLENBQUNDLElBQUgsS0FBWUQsRUFBRSxDQUFDVixHQUFuQixFQUF3QjtBQUN4QixVQUFNeEIsSUFBSSxHQUFHRCxPQUFPLENBQUNXLEdBQUQsRUFBTSxHQUFHd0IsRUFBRSxDQUFDakIsU0FBSCxDQUFhVSxLQUFiLENBQW1CLEdBQW5CLENBQVQsRUFBa0NPLEVBQUUsQ0FBQ2hCLFFBQXJDLENBQXBCO0FBQ0FILElBQUFBLE9BQU8sQ0FBQ2EsSUFBUixDQUFhLENBQUMsR0FBR00sRUFBRSxDQUFDakIsU0FBSCxDQUFhVSxLQUFiLENBQW1CLEdBQW5CLENBQUosRUFBNkJPLEVBQUUsQ0FBQ2hCLFFBQWhDLEVBQTBDVyxNQUExQyxDQUFpREMsQ0FBQyxJQUFJQSxDQUF0RCxFQUF5REosSUFBekQsQ0FBOEQsR0FBOUQsQ0FBYjtBQUNBLFFBQUlqQixLQUFKLEVBQVcsdUJBQWNULElBQWQsRUFBb0JrQyxFQUFFLENBQUNDLElBQXZCO0FBQ1osR0FORDtBQU9BLFNBQU9wQixPQUFQO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB3cml0ZUZpbGVTeW5jIH0gZnJvbSAnZnMnXHJcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnXHJcbmltcG9ydCBiYWNrdXAgZnJvbSAnLi4vbWFrZXJzL2JhY2t1cCdcclxuY29uc3QgeyByZXNvbHZlIH0gPSBwYXRoXHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZml4IChjb25maWcsIHByb2plY3QpIHtcclxuICBiYWNrdXAoY29uZmlnKVxyXG4gIGFwcGx5TGlicmFyaWVzKGNvbmZpZywgcHJvamVjdC5maWxlcywgcHJvamVjdC5saWJzLCB0cnVlKVxyXG4gIGFwcGx5VGVtcGxhdGVzKGNvbmZpZywgcHJvamVjdC50ZW1wbGF0ZXMsIHRydWUpXHJcbn1cclxuXHJcbi8qKlxyXG4gKiBiYWNrdXAgYmVmb3JlIHVzaW5nXHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gYXBwbHlMaWJyYXJpZXMgKGNvbmZpZywgZmlsZXMsIGxpYnMsIGFwcGx5ID0gZmFsc2UpIHtcclxuICBjb25zdCBzcmMgPSByZXNvbHZlKHByb2Nlc3MuY3dkKCksIGNvbmZpZy5Xb3JraW5nRGlyLCBjb25maWcuU3JjRGlyKVxyXG4gIGNvbnN0IGNoYW5nZXMgPSBbXVxyXG4gIGZpbGVzLmZvckVhY2goKHtuYW1lc3BhY2UsIGZpbGVuYW1lLCBkYXRhfSkgPT4ge1xyXG4gICAgbGV0IGNoYW5nZWQgPSBmYWxzZVxyXG4gICAgY29uc3QgcmVmYWNydG9yZWQgPSBkYXRhXHJcbiAgICAgIC5tYXAobmFtZSA9PiB7XHJcbiAgICAgICAgaWYgKGxpYnNbbmFtZV0ub2xkICE9PSBsaWJzW25hbWVdLnJlZmFjdG9yZWQpIGNoYW5nZWQgPSB0cnVlXHJcbiAgICAgICAgcmV0dXJuIGxpYnNbbmFtZV0ucmVmYWN0b3JlZFxyXG4gICAgICB9KVxyXG4gICAgICAuam9pbignXFxuJylcclxuICAgIGlmICghY2hhbmdlZCkgcmV0dXJuXHJcbiAgICBjb25zdCBwYXRoID0gcmVzb2x2ZShzcmMsIC4uLm5hbWVzcGFjZS5zcGxpdCgnLycpLCBmaWxlbmFtZSlcclxuICAgIGNoYW5nZXMucHVzaChbLi4ubmFtZXNwYWNlLnNwbGl0KCcvJyksIGZpbGVuYW1lXS5maWx0ZXIoZSA9PiBlKS5qb2luKCcvJykpXHJcbiAgICBpZiAoYXBwbHkpIHdyaXRlRmlsZVN5bmMocGF0aCwgcmVmYWNydG9yZWQpXHJcbiAgfSlcclxuICByZXR1cm4gY2hhbmdlc1xyXG59XHJcblxyXG4vKipcclxuICogYmFja3VwIGJlZm9yZSB1c2luZ1xyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5VGVtcGxhdGVzIChjb25maWcsIHRlbXBsYXRlcywgYXBwbHkgPSBmYWxzZSkge1xyXG4gIGNvbnN0IHNyYyA9IHJlc29sdmUocHJvY2Vzcy5jd2QoKSwgY29uZmlnLldvcmtpbmdEaXIsIGNvbmZpZy5TcmNEaXIpXHJcbiAgY29uc3QgY2hhbmdlcyA9IFtdXHJcbiAgT2JqZWN0LmtleXModGVtcGxhdGVzKS5mb3JFYWNoKGtleSA9PiB7XHJcbiAgICBjb25zdCBlbCA9IHRlbXBsYXRlc1trZXldXHJcbiAgICBpZiAoZWwuY29kZSA9PT0gZWwub2xkKSByZXR1cm5cclxuICAgIGNvbnN0IHBhdGggPSByZXNvbHZlKHNyYywgLi4uZWwubmFtZXNwYWNlLnNwbGl0KCcvJyksIGVsLmZpbGVuYW1lKVxyXG4gICAgY2hhbmdlcy5wdXNoKFsuLi5lbC5uYW1lc3BhY2Uuc3BsaXQoJy8nKSwgZWwuZmlsZW5hbWVdLmZpbHRlcihlID0+IGUpLmpvaW4oJy8nKSlcclxuICAgIGlmIChhcHBseSkgd3JpdGVGaWxlU3luYyhwYXRoLCBlbC5jb2RlKVxyXG4gIH0pXHJcbiAgcmV0dXJuIGNoYW5nZXNcclxufVxyXG4iXX0=